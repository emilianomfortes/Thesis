import numpy as np

#----------------  BINARY OPERATIONS  ----------------#

def btest(i, pos): #btest translated
    return bool(i & (1 << pos))

def set_bit(v, index, x): #ibclr if x=0 and ibset if x=1 translated
  """Set the index:th bit of v to 1 if x is truthy, else to 0, and return the new value."""
  mask = 1 << index   
  v &= ~mask
  if x:
    v |= mask
  return v

#----------------  SPIN OPERATIONS  ----------------#

# Pauli at site operators

def S_xi(pos_i,sites):
    dim = 2**sites
    S = np.zeros((dim,dim),dtype=complex)
    estados2 = np.zeros(dim,dtype=np.int64)
    for i in range(dim):
        if btest(i,pos_i) == True:
            estados2[i] = set_bit(i,pos_i,0)
        else:
            estados2[i] = set_bit(i,pos_i,1)
    for i in range(dim):
        for j in range(dim):
            if i == estados2[j]:
                S[i,j] = S[i,j]+1
    return S

def S_yi(pos_i,sites):
    dim = 2**sites
    S = np.zeros((dim,dim),dtype=complex)
    estados2 = np.zeros(dim,dtype=np.int64)
    a = np.zeros(dim,dtype=complex)
    for i in range(dim):
        if btest(i,pos_i) == True:
            estados2[i] = set_bit(i,pos_i,0)
            a[i] = 1j
        else:
            estados2[i] = set_bit(i,pos_i,1)
            a[i] = -1j
    for i in range(dim):
        for j in range(dim):
            if i == estados2[j]:
                S[i,j] = S[i,j]+a[j]
    return S
    
def S_zi(pos_i,sites):
    dim = 2**sites
    S = np.zeros((dim,dim),dtype=complex)
    for i in range(dim):
        if btest(i,pos_i) == True:
            S[i,i] = 1
        else:
            S[i,i] = -1
    return S

# Nearest-neighbor interactions

def S_xxij(pos_i,pos_j,sites):
    dim = 2**sites
    S = np.zeros((dim,dim),dtype=complex)
    estados2 = np.zeros(dim,dtype=np.int64)
    for i in range(dim):
        if btest(i,pos_i) == True:
            estados2[i] = set_bit(i,pos_i,0)
        else:
            estados2[i] = set_bit(i,pos_i,1)
    for i in range(dim):
        if btest(estados2[i],pos_j) == True:
            estados2[i] = set_bit(estados2[i],pos_j,0)
        else:
            estados2[i] = set_bit(estados2[i],pos_j,1)
    for i in range(dim):
        for j in range(dim):
            if i == estados2[j]:
                S[i,j] = S[i,j]+1
    return S

def S_yyij(pos_i,pos_j,sites):
    dim = 2**sites
    S = np.zeros((dim,dim),dtype=complex)
    estados2 = np.zeros(dim,dtype=np.int64)
    a = np.zeros(dim,dtype=complex)
    for i in range(dim):
        if btest(i,pos_i) == True:
            estados2[i] = set_bit(i,pos_i,0)
            a[i] = 1j
        else:
            estados2[i] = set_bit(i,pos_i,1)
            a[i] = -1j
    #estados2 = estados2.astype(np.int64)
    for i in range(dim):
        if btest(estados2[i],pos_j) == True:
            estados2[i] = set_bit(estados2[i],pos_j,0)
            a[i] = a[i]*1j
        else:
            estados2[i] = set_bit(estados2[i],pos_j,1)
            a[i] = -a[i]*1j
    for i in range(dim):
        for j in range(dim):
            if i == estados2[j]:
                S[i,j] = S[i,j]+a[j]
    return S

def S_zzij(pos_i,pos_j,sites):
    dim = 2**sites
    S = np.zeros((dim,dim),dtype=complex)
    for i in range(dim):
        if btest(i,pos_i) == True:
            if btest(i,pos_j) == True:
                S[i,i] = 1
            else:
                S[i,i] = -1
        else:
            if btest(i,pos_j) == True:
                S[i,i] = -1
            else:
                S[i,i] = 1
    return S
    
def Parity(sites): # Returns the parity operator in the S_z base
    dim = 2 ** sites
    identity = np.zeros((dim,dim),dtype=complex)
    zeros = np.zeros((4,4),dtype=complex)
    for n in range(dim):
        identity[n,n] = 1
    Dx = np.matrix([[0,1],[1,0]],dtype=complex)
    Dy = np.matrix([[0,-1j],[1j,0]],dtype=complex)
    Dz = np.matrix([[1,0],[0,-1]],dtype=complex)
    Parity = identity
    if sites % 2 == 0:
        tt = sites/2
    else:
        tt = (sites-1)/2
    for u in range(tt):
        P = 0.5* (identity + np.matmul(S_x_i(u,sites),S_x_i(sites-1-u,sites)) + np.matmul(S_y_i(u,sites),S_y_i(sites-1-u,sites)) + np.matmul(S_z_i(u,sites),S_z_i(sites-1-u,sites)) )
        Parity = np.matmul(Parity,P)
    return Parity
    
#----------------  OUT-OF-TIME-ORDERED CORRELATORS  ----------------#

#### WITH TEMPERATURE CHOICES (IF T=INFTY USE INFTY TEMPERATURE OTOCS FOR EXTRA SPEED)

def OTOC(V,W,ener,basis,N,dt,t0,beta,ortho):
    dim = len(ener)
    if ortho == True:
        basist = np.transpose(basis)
    else:
        basist = np.linalg.inv(basis)
    ope0 = np.matmul(basist,V)
    ope0 = np.matmul(ope0,basis)
    ope = np.matmul(basist,W)
    ope = np.matmul(ope,basis)
    otoc=[]
    mm = np.zeros((dim,dim),dtype=complex)
    mm1 = np.zeros((dim,dim),dtype=complex)
    ensemblemedio = dim
    ensemble = np.identity(dim,dtype=complex)
    if beta =! 0:
        for i in range(0,dim):
            ensemble[i][i] = np.exp(-beta*ener[i])
        ensemblemedio = np.abs(np.matrix.trace(ensemble))
    U = np.zeros((dim,dim),dtype=complex) # U evolucion temporal
    Udagger = np.zeros((dim,dim),dtype=complex) # U*   
    for count0 in range(0,N):
        tie = count0*dt+t0
        tiempo.append(tie)
        for count1 in range(0,dim):
            U[count1][count1] = np.exp(-1j*tie*ener[count1])
            Udagger[count1][count1] = np.exp(1j*tie*ener[count1])
        mm = np.matmul(ope0,U)
        mm1= np.matmul(Udagger,mm)
        mm = np.matmul(mm1,ope) - np.matmul(ope,mm1)
        mm = np.matmul(np.transpose(np.conjugate(mm)),mm)
        mm = np.matmul(ensemble,mm)
        otoc.append(0.5*np.abs(np.matrix.trace(mm)) / ensemblemedio )
    return otoc

#### INFTY TEMPERATURE OTOCS

## Calculates OTOC OPTMIZED SPEED
start_time = timeit.default_timer()

mm = np.zeros((len(ener),len(ener)),dtype="complex64")
mm1 = np.zeros((len(ener),len(ener)),dtype="complex64")
mm2 = np.zeros((len(ener),len(ener)),dtype="complex64")
mm = np.copy(mm, order='F')
mm1= np.copy(mm1, order='F')
mm2=np.copy(mm2, order='F')
otok = np.zeros(N,dtype = "float32")
U = np.zeros((len(ener),len(ener)),dtype="complex64") # U evolucion temporal
Udagger = np.zeros((len(ener),len(ener)),dtype="complex64") # U*
U = np.copy(U, order='F')
Udagger = np.copy(Udagger, order='F')
for ti in range(0,N):
    #start_time = timeit.default_timer()
    for c1 in range(0,len(ener)):
        U[c1][c1] = np.exp(-1j*tiempo[ti]*ener[c1])
        Udagger[c1][c1] = np.exp(1j*tiempo[ti]*ener[c1])
    mm = FB.cgemm(1,S0,U)
    mm1= FB.cgemm(1,Udagger,mm)
    mm = FB.cgemm(1,mm1,S) - FB.cgemm(1,S,mm1)
    mm2 = FB.cgemm(1,np.transpose(np.conjugate(mm)),mm)
    otok[ti] = 0.5*(np.abs(np.matrix.trace(mm2))/len(ener)) 
    #elapsed = timeit.default_timer() - start_time
    #print(elapsed) 
otok = np.array(otok)

elapsed = timeit.default_timer() - start_time
print(r"OTOC_FAST took "+str(elapsed))
 
np.savetxt('otok_fast.txt', otok , fmt='%.18g', delimiter=' ')

## Calculates OTOC 1-F SLOW
start_time = timeit.default_timer()

S0 = tss.S_z_i_sectores(l0,statedata_full)
S0 = np.matmul(S0,basis)
S0 = np.matmul(np.transpose(basis),S0)
S = tss.S_z_i_sectores(ls,statedata_full)
S = np.complex64(S)
S = np.matmul(S,basis)
S = np.matmul(np.transpose(basis),S)
mm = np.zeros((len(ener),len(ener)),dtype=complex)
mm1 = np.zeros((len(ener),len(ener)),dtype=complex)
mm2 = np.zeros((len(ener),len(ener)),dtype=complex)
otok = np.zeros(N,dtype = float)
U = np.zeros((len(ener),len(ener)),dtype=complex) # U evolucion temporal
Udagger = np.zeros((len(ener),len(ener)),dtype=complex) # U*
for ti in range(0,N):
    #start_time = timeit.default_timer()
    for c1 in range(0,len(ener)):
        U[c1][c1] = np.exp(-1j*tiempo[ti]*ener[c1])
        Udagger[c1][c1] = np.exp(1j*tiempo[ti]*ener[c1])
    mm = np.matmul(S0,U)
    mm1= np.matmul(Udagger,mm)
    mm = np.matmul(mm1,S)
    mm2 = np.matmul(mm,mm)
    otok[ti] = 1 - (np.matrix.trace(mm2)/len(ener)).real 
    #elapsed = timeit.default_timer() - start_time
    #print(elapsed) 
otok = np.array(otok)

elapsed = timeit.default_timer() - start_time
print(r"OTOCF_SLOW took "+str(elapsed))

np.savetxt('otokf_slow.txt', otok , fmt='%.18g', delimiter=' ')

## Calculates OTOC SLOW
start_time = timeit.default_timer()

mm = np.zeros((len(ener),len(ener)),dtype=complex)
mm1 = np.zeros((len(ener),len(ener)),dtype=complex)
mm2 = np.zeros((len(ener),len(ener)),dtype=complex)
otok = np.zeros(N,dtype = float)
U = np.zeros((len(ener),len(ener)),dtype=complex) # U evolucion temporal
Udagger = np.zeros((len(ener),len(ener)),dtype=complex) # U*
for ti in range(0,N):
    #start_time = timeit.default_timer()
    for c1 in range(0,len(ener)):
        U[c1][c1] = np.exp(-1j*tiempo[ti]*ener[c1])
        Udagger[c1][c1] = np.exp(1j*tiempo[ti]*ener[c1])
    mm = np.matmul(S0,U)
    mm1= np.matmul(Udagger,mm)
    mm = np.matmul(mm1,S) - np.matmul(S,mm1)
    mm2 = np.matmul(np.transpose(np.conjugate(mm)),mm)
    otok[ti] = 0.5*(np.abs(np.matrix.trace(mm2))/len(ener)) 
    #elapsed = timeit.default_timer() - start_time
    #print(elapsed) 
otok = np.array(otok)

elapsed = timeit.default_timer() - start_time
print(r"OTOC_SLOW took "+str(elapsed))
